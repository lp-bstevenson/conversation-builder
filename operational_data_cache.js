function lambda(input, callback) {
    // import Toolbelt
    const { Toolbelt, LpServices } = require("lp-faas-toolbelt");
    const lpClient = Toolbelt.LpClient();
    const httpClient = Toolbelt.HTTPClient(); // For API Docs look @ https://www.npmjs.com/package/request-promise
    const secretClient = Toolbelt.SecretClient();  
    const OAuth = require('oauth-1.0a');
    const crypto = require('crypto');
    // DEFINE NAMESPACE TO BE USED BY DYNAMIC ROUTING
    // const namespace = 'OPERATIONAL_DATA'
    const ttlSecond = 2 * 60000; // TIME TO LIVE FOR CONTEXT STORE DATA
    const tokenSecretName = 'FAAS-Runner-Bot-01' // auth token generated by Bot Runner secondary function
    const mavenApiKey = 'mavenApiKey' // secret KEY name for conversation orchestrator (AKA "maven-api-key")
    const log = (e) => {console.info(JSON.stringify(e))}

    /*
    NOTEs:
    - This function requires the secondary BOT RUNNER to provide a valid bearer Token (Shift Status requires bearer token methodology for an array of skill data)
    - If Shift Status is not required, APP KEY method may be employed to request data from Queue, Agent Status APIs.
    - This function is using the BEARER TOKEN method for Conversational Cloud API calls

    - Timezone Data is requested from https://timezonedb.com/
    - A free account can be created allowing for 1 request per second (more than adequate for this process)
    */
  
    const main = async (input, callback) => {

      const getZones = async () => {
        const TZDB_KEY = 'RJP1FR6ACKX3'
        try {
        var response = await httpClient(`http://api.timezonedb.com/v2.1/list-time-zone?key=${TZDB_KEY}&format=json`, {
          method: "GET",
        })
        return { successResult: true, response: JSON.parse(response)}
        } catch (err) {
          return { successResult: false, err: err}
        }
      }

      const createNamespace = async (maven_key, namespace) => {        
        var res = await httpClient(`https://z3.context.liveperson.net/v1/account/${process.env.BRAND_ID}?ttlSecond=${ttlSecond}`, {
            method: "POST",        
            headers: {
              "maven-api-key": maven_key,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ "name": namespace}),
            simple: false, // IF true => Status Code != 2xx & 3xx will throw
            resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
          })          
          .then(response => {
            // console.info(`created namespace: ${namespace}, ${JSON.stringify(res)}`)
          return {
            successResult: true,
            response: response
          };
        })
        .catch(err => {
          console.error(`CREATE NAMESPACE ${JSON.stringify(err)}`);
          return {
            successResult: false
          };          
        });
        return res;
      }

      const saveToNameSpace = async (data, maven_key, namespace, key) => {
        var res = await httpClient(`https://z3.context.liveperson.net/v1/account/45664977/${namespace}/properties`, {
            method: "PATCH",        
            headers: {
              "maven-api-key": maven_key,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data),
            simple: false, // IF true => Status Code != 2xx & 3xx will throw
            resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
          })          
          .then(response => {
            console.info(`Saved to namespace: ${namespace}, ${key}, ${JSON.stringify(response)}`)
          return {
            successResult: true,
            response: response
          };
        })
        .catch(err => {
          console.error(`NAMESPACE ${JSON.stringify(err)}`);
          return {
            successResult: false
          };          
        });
        return res;
      }

      const getWDProfiles = async () => {
        const options = { method: 'GET', 'Content-type': 'application/json', 'Accept': 'application/json' }
        try {
          const response = await lpClient(
          LpServices.ACCOUNT_CONFIG_READ_ONLY, // LP service name
          `/api/account/${process.env.BRAND_ID}/configuration/ac-common/workinghours`,
          options // options
        )
        return { successResult: true, response: JSON.parse(response)}
        } catch (err) {
          return { successResult: false, err: err}
        }
      }

      const getAccountConfigSettings = async (bearer) => {
        try {
          const response = await httpClient(`https://sy.ac.liveperson.net/api/account/${process.env.BRAND_ID}/configuration/setting/properties?v=3.0&source=ccuiUm&context_type=ACCOUNT&context_cascading=true`, {
          method: "GET", // HTTP VERB
          headers: {
            'Content-Type': 'application/json; charset=utf-8',
            'Connection': 'keep-alive',
            "Authorization": `Bearer ${bearer}`
          },
          simple: false, // IF true => Status Code != 2xx & 3xx will throw
          resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
        })
        let data = JSON.parse(response)
        let acr = {
          defaultResponseTime: data.find(x => x.id === 'messaging.default.response.time').propertyValue.value,
          urgentResponseTime: data.find(x => x.id === 'messaging.default.response.urgent.time').propertyValue.value,
          firstResponseTime: data.find(x => x.id === 'messaging.default.response.prioritized.time').propertyValue.value,
          language: data.find(x => x.id === 'le.general.language').propertyValue.value,
          timezone: data.find(x => x.id === 'le.general.timezone').propertyValue.value,
          maxConversations: data.find(x => x.id === 'messaging.max.conversions').propertyValue.value,
        }
        return { successResult: true, response: acr };
        } catch (err) {
          console.error(`ACCOUNT CONFIG ${JSON.stringify(err)}`);          
          return { successResult: false, error: err };          
        }
      }
      
      const getSkills = async () => {
        try {
          const response = await lpClient(
            LpServices.ACCOUNT_CONFIG_READ_ONLY, `/api/account/${process.env.BRAND_ID}/configuration/le-users/skills?v=2.0&select=$all`, 
            { method: "GET" }
          )          
          const skills = JSON.parse(response)
          return { successResult: true, response: skills };
        } catch (err) {  
          console.error(`SKILLS ${JSON.stringify(err)}`);
          return { successResult: false, error: err };          
        }
      }

      const getShiftStatus = async (bearer) => {
        try {
          const response = await httpClient(`https://sy.msg.liveperson.net/api/account/${process.env.BRAND_ID}/shift-status`, {
          method: "GET", // HTTP VERB
          headers: { "Authorization": `Bearer ${bearer}` },
          simple: false, // IF true => Status Code != 2xx & 3xx will throw
          resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
        })
        const shiftStatus = JSON.parse(response)
        return { successResult: true, response: shiftStatus };
        } catch (err) {
          console.error(`SHIFT STATUS ${JSON.stringify(err)}`);
          return { successResult: false, error: err };          
        }
      }

      const getAgentStatus = async (bearer) => {
        try {
          const response = await httpClient(`https://sy.msghist.liveperson.net/messaging_history/api/account/${process.env.BRAND_ID}/agent-view/status?limit=1500`, {
          method: "POST", // HTTP VERB
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Authorization": `Bearer ${bearer}`
          },
          body: JSON.stringify({}),
          simple: false, // IF true => Status Code != 2xx & 3xx will throw
          resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
        })
        let data = JSON.parse(response)
        let agentStatusRecords = data.agentStatusRecords
        return { successResult: true, response: agentStatusRecords }
        } catch (err) {
          console.error(`AGENT STATUS ${JSON.stringify(err)}`);
          return { successResult: false, error: err };          
        }
      }

      const getCurrentQueue = async (bearer) => {        
        try {
          const response = await httpClient(`https://sy.data.liveperson.net/operations/api/account/${process.env.BRAND_ID}/msgqueuehealth/current/?v=1`, {
          method: "GET", // HTTP VERB
          headers: { "Authorization": `Bearer ${bearer}` },
          simple: false, // IF true => Status Code != 2xx & 3xx will throw
          resolveWithFullResponse: false //IF true => Includes Status Code, Headers etc.
        })
        const e = JSON.parse(response)
        /*
        // FULL LIST OF ATTRIBUTES AVAILABLE
        avgWaitTimeForAgentAssignment_AfterTransferFromAgent
        actionableConversations
        unassignedConversationsAndFirstTimeConsumer
        avgWaitTimeForAgentAssignment_NewConversation
        notActionableDuringTransfer
        actionableAndConsumerLastMessage
        actionableAndDuringTransfer
        maxWaitTimeForAgentAssignment_AfterTransferFromAgent
        waitTimeForAgentAssignment_50thPercentile
        notActionableConversations
        unassignedConversations
        waitTimeForAgentAssignment_90thPercentile
        actionableAndManualSla
        time
        maxWaitTimeForAgentAssignment
        notActionableAndManualSla
        avgWaitTimeForAgentAssignment_AfterTransfer
        avgWaitTimeForAgentAssignment_AfterTransferFromBot
        */
          return { successResult: true, response: e };
        } catch (err) {      
          console.error(`QUEUE STATUS ${JSON.stringify(err)}`);
          return { successResult: false, error: err };          
        }
      }

      const retreiveAllData = async () => {
        // 1. Prepare tokens and namespace
        const maven_key = await secretClient.readSecret(mavenApiKey);        
        createNamespace(maven_key.value, 'OPERATIONAL_DATA');
        createNamespace(maven_key.value, 'OPERATIONAL_DATA_FLAT');
        const token = await secretClient.readSecret(tokenSecretName);
        // 2. Gather data         
        let skillsResponse = await getSkills()        
        if (!skillsResponse.successResult) return { successResult: false }
        // console.info("skillsResponse: " + JSON.stringify(skillsResponse))

        // get Account Config Settings (Default values configured in LiveEngage - A.K.A Conversational Cloud)
        const accountConfigResponse = await getAccountConfigSettings(token.value.bearer, maven_key.value)
        if (!accountConfigResponse.successResult) return { success: false}        
        const accountConfig = accountConfigResponse.response
        console.info("accountConfig: " + JSON.stringify(accountConfig))

        // get Agent Status results
        const agentStatusResponse = await getAgentStatus(token.value.bearer, maven_key.value)
        if (!agentStatusResponse.successResult) return { success: false}        
        const agentStatus = agentStatusResponse.response
        // console.info("agentStatus: " + JSON.stringify(agentStatus))

        // get Shift Status
        const shiftStatus = await getShiftStatus(token.value.bearer, maven_key.value)
        if (!shiftStatus.successResult) return { success: false}
        const shifts = shiftStatus.response
        // console.info("shifts: " + JSON.stringify(shifts))

        // get Working Day Profiles
        const workingDayProfilesResponse = await getWDProfiles()
        // console.info("workingDayProfile: " + JSON.stringify(workingDayProfilesResponse))
        if (!workingDayProfilesResponse.successResult) return { success: false}
        const workingDayProfile = workingDayProfilesResponse.response
        

        // get Queue Status
        const queueStatusResponse  = await getCurrentQueue(token.value.bearer, maven_key.value)
        if (!queueStatusResponse.successResult) return { success: false}
        const queueStatus = queueStatusResponse.response
        // console.info("queueStatus: " + JSON.stringify(queueStatus))

        // get timezones from Timezone.db
        const tzdb = await getZones()
        const zones = tzdb.response.zones
        // console.info("zones: " + JSON.stringify(zones))
        let result = { zones: zones}

        // 3. transform SKILLS array to a "Skill-Orientated" Object and add additional data points
        let hasDefaultWDProfile = false
        let defaultWDProfile = {}
        let defaultTimezone = ""
        for (var wd in workingDayProfile) {
            workingDayProfile[wd].timezone = ""    
            if (workingDayProfile[wd].isDefault === true) {
                hasDefaultWDProfile = true
                defaultWDProfile = workingDayProfile[wd]
                for (k in workingDayProfile[wd].events) {
                    if (hasOwnProperty.call(workingDayProfile[wd].events[k], 'start')) {
                        defaultTimezone = workingDayProfile[wd].events[k].start.timeZone
                        workingDayProfile[wd].timezone = workingDayProfile[wd].events[k].start.timeZone                                
                    }
                }        
            }
        }
        let flatData = {}
        let skills = {}
        const skillsArray = skillsResponse.response
        console.info("skillsArray: " + JSON.stringify(skillsArray))
        for (var i in skillsArray) {
          let id = skillsArray[i].id
          if (!id) { log(skillsArray[i]); continue }
          // log(id)
          flatData[`skillname_${id}`]
          
          let obj = skillsArray[i]
          obj.shift = shifts.find(x => x.skillId.toString() === skillsArray[i].id.toString())
          obj.timezone = accountConfig.timezone
          // add working Day Profile
          if (hasDefaultWDProfile) {
              obj.workingDayProfile = defaultWDProfile
              obj.timezone = defaultTimezone
          }
          flatData[`timezone_${id}`] = obj.timezone
          if (hasOwnProperty.call(skillsArray[i], 'workingHoursId')) {
              obj.workingDayProfile = workingDayProfile.find(x => x.id === skillsArray[i].workingHoursId)
          }
          // model for agentStatus
          obj.agentStatus = {
              onlineAgents: 0,
              load: 0,
              configuredMaxSlots: 0,
              busySlots: 0,
              openAssignedConversations: 0
          }
          // add raw Queue Status Object (skillsMetrics only, totals disregarded)
          obj.queueStatus = !!queueStatus.skillsMetrics[skillsArray[i].id.toString()] ? queueStatus.skillsMetrics[skillsArray[i].id.toString()] : false
          flatData[`unassignedConversations_${id}`] = obj.queueStatus.unassignedConversations
          
          skills[skillsArray[i].id] = obj
        }
        // iterate on agentStatus and append to skills Object
        for (i in agentStatus) {
            if (agentStatus[i].currentStatus.toLowerCase() !== 'online') continue
            for (s in agentStatus[i].agentSkills) {
                let skillId = agentStatus[i].agentSkills[s].skillId
                if (hasOwnProperty.call(skills, skillId.toString())) {
                    skills[skillId.toString()].agentStatus.onlineAgents++

                    skills[skillId.toString()].agentStatus.load += agentStatus[i].load
                    skills[skillId.toString()].agentStatus.configuredMaxSlots += agentStatus[i].configuredMaxSlots
                    skills[skillId.toString()].agentStatus.busySlots += agentStatus[i].busySlots
                    skills[skillId.toString()].agentStatus.openAssignedConversations += agentStatus[i].openAssignedConversations
                }
            }
        }
        for (i in skills) {
          flatData[`onlineAgents_${skills[i].id}`] = skills[i].agentStatus.onlineAgents
          let timezoneDetail = zones.find(x => x.zoneName === skills[i].timezone)
          skills[i].timezoneDetail = !!timezoneDetail ? timezoneDetail : {}
          // flatData[`load_${id}`] = skills[i].agentStatus.load
          // flatData[`configuredMaxSlots_${id}`] = skills[i].agentStatus.configuredMaxSlots
          // flatData[`busySlots_${id}`] = skills[i].agentStatus.busySlots
          // flatData[`openAssignedConversations_${id}`] = skills[i].agentStatus.openAssignedConversations
        }        
        
        // log(`flatData: ${JSON.stringify(flatData)}`)

        saveToNameSpace(
          flatData,
          maven_key.value,
          'OPERATIONAL_DATA_FLAT',
          'flat'
        )

       const OPERATIONAL_DATA_RESPONSE = await saveToNameSpace(
          { detailed: skills, accountConfig: accountConfig, zones: zones, last_update: Date.now() },          
          maven_key.value,
          'OPERATIONAL_DATA',
          'detailed'
          )
        log(OPERATIONAL_DATA_RESPONSE)
        return skills
      }

      callback(null, retreiveAllData())

    }

    main(input, callback)

  }
  
  